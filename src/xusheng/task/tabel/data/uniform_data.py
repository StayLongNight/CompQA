# -*- coding:utf-8 -*-

import json
import numpy as np
from kangqi.util.LogUtil import LogInfo

# Python format data (numpy) for tensorflow model input
# Process from JSON file generated by Java code, which mainly covers
# tasks such as word2vec lookup, redirect/inter-language process, candidate generation etc,.


PN = 50

def get_0_w2v():
    return [0.0 for _ in range(100)]

def get_0_label():
    return [0.0 for _ in range(PN)]

def get_0_mask():
    return [0.0 for _ in range(PN)]

def get_1_mask():
    return [1.0 for _ in range(PN)]

def get_0_candidates():
    vec = list()
    for i in range(PN):
        vec.append(get_0_w2v())
    return vec

def is_zero(vec):
    if vec[0] == 0.0 and vec[1] == 0.0 and vec[2] == 0.0:
        return True
    else:
        return False

def get_uniform_data():
    data = dict()
    data['cell'] = list()
    data['context'] = list()
    data['entity'] = list()
    data['mask'] = list()
    data['label'] = list()
    data['truth'] = list()
    name = dict()
    name['entity'] = dict()
    name['truth'] = dict()
    name['surface'] = dict()

    data_fp = "/home/xusheng/PythonProject/data/tabel/monolingual/uniform_data.json"
    # .baidu stands for only using baidu as translation tool
    br = open(data_fp, 'rb')
    rows = 16
    cols = 6

    LogInfo.begin_track("Convert data...")
    stables = json.loads(br.readline())
    br.close()
    LogInfo.begin_track("Generate cell & entity & mask & label tensors...")
    for i_1, stable in enumerate(stables):
        LogInfo.logs("Converting table %d...", i_1+1)
        cetable = list()
        etable = list()
        mtable = list()
        ltable = list()
        trtable = list()
        row_num = 0
        for srow in stable:
            row_num += 1
            cerow = list()
            erow = list()
            mrow = list()
            lrow = list()
            trrow = list()
            col_num = 0
            for scell in srow:
                col_num += 1
                # ***** inside one cell ***** #
                cecell = get_0_w2v()
                ecell = get_0_candidates()
                mcell = get_0_mask()
                lcell = get_0_label()
                trcell = get_0_w2v()

                if not scell["empty"]:
                    truth_idx = "%d_%d_%d" % (i_1, row_num - 1, col_num - 1)
                    name['surface'][truth_idx] = scell['mention']
                    cecell = [float(val) for val in scell['mentionVec'].strip().split(" ")]
                    if "entityVec" in scell: # cell to link
                        name['truth'][truth_idx] = [scell['en-entity'], scell['zh-entity'], scell['mention']]
                        trcell = [float(val) for val in scell['entityVec'].strip().split(" ")]
                        mcell = get_1_mask()
                        ecell = list()
                        candidates = scell["candidates"]
                        for i_2, candidate in enumerate(candidates):
                            candi_idx = "%d_%d_%d_%d" % (i_1, row_num-1, col_num-1, i_2)
                            candi_name = candidate["entity"][2:-2]
                            name['entity'][candi_idx] = candi_name
                            vec = [float(val) for val in candidate["vec"].strip().split(" ")]
                            ecell.append(vec)
                        if scell["true-pos"] != -1:
                            lcell[scell["true-pos"]] = 1
                # ***** inside one cell ***** #
                cerow.append(cecell)
                erow.append(ecell)
                mrow.append(mcell)
                lrow.append(lcell)
                trrow.append(trcell)
            # **** filling cell zeros for each row *** #
            for i in range(cols - col_num):
                cerow.append(get_0_w2v())
                erow.append(get_0_candidates())
                mrow.append(get_0_mask())
                lrow.append(get_0_label())
                trrow.append(get_0_w2v())
            # **** filling cell zeros for each row *** #
            cetable.append(cerow)
            etable.append(erow)
            mtable.append(mrow)
            ltable.append(lrow)
            trtable.append(trrow)
        # *** filling row zeros for each table *** #
        for i in range(rows - row_num):
            zcerow = list()
            zerow = list()
            zmrow = list()
            zlrow = list()
            ztrrow = list()
            for j in range(cols):
                zcerow.append(get_0_w2v())
                zerow.append(get_0_candidates())
                zmrow.append(get_0_mask())
                zlrow.append(get_0_label())
                ztrrow.append(get_0_w2v())
            cetable.append(zcerow)
            etable.append(zerow)
            mtable.append(zmrow)
            ltable.append(zlrow)
            trtable.append(ztrrow)
        # *** filling row zeros for each table *** #
        data['cell'].append(cetable)
        data['entity'].append(etable)
        data['mask'].append(mtable)
        data['label'].append(ltable)
        data['truth'].append(trtable)
    LogInfo.logs("Cell & entity & mask & label & truth tensors generated.")
    LogInfo.end_track()

    LogInfo.begin_track("Generate context tensor from cell tensor...")
    cell_tensor = data['cell']
    table_num = len(cell_tensor)
    for i in range(table_num):
        LogInfo.logs("Generating table %d...", i+1)
        cotable = list()
        for j in range(rows):
            corow = list()
            for k in range(cols):
                cocell = get_0_w2v()
                if data['mask'][i][j][k][0] == 1: # cell to link
                    cnt = 0
                    sum_vec = np.array(get_0_w2v())
                    for r in range(rows):
                        if r != j and not(is_zero(cell_tensor[i][r][k])):
                            sum_vec += np.array(cell_tensor[i][r][k])
                            cnt += 1
                    for c in range(cols):
                        if c != k and not(is_zero(cell_tensor[i][j][c])):
                            sum_vec += np.array(cell_tensor[i][j][c])
                            cnt += 1
                    if cnt != 0:
                        sum_vec /= cnt
                    cocell = sum_vec
                corow.append(cocell)
            cotable.append(corow)
        data['context'].append(cotable)
    LogInfo.logs("Context tensor from cell tensor generated.")
    LogInfo.end_track()
    LogInfo.logs("cell shape: %s", np.array(data['cell']).shape)
    LogInfo.logs("context shape: %s", np.array(data['context']).shape)
    LogInfo.logs("entity shape: %s", np.array(data['entity']).shape)
    LogInfo.logs("mask shape: %s", np.array(data['mask']).shape)
    LogInfo.logs("label shape: %s", np.array(data['label']).shape)
    LogInfo.logs("truth shape: %s", np.array(data['truth']).shape)
    LogInfo.end_track()

    return data, name

if __name__ == "__main__":
    data, name = get_uniform_data()
    with open("/home/xusheng/PythonProject/data/tabel/monolingual/uniform_data.dump", "w") as bw:
        np.save(bw, data['cell'])
        np.save(bw, data['context'])
        np.save(bw, data['entity'])
        np.save(bw, data['mask'])
        np.save(bw, data['label'])
        np.save(bw, data['truth'])
    LogInfo.logs("Data saved.")

    import codecs
    import sys

    reload(sys)
    sys.setdefaultencoding('utf-8')

    UTF8Writer = codecs.getwriter('utf8')
    sys.stdout = UTF8Writer(sys.stdout)

    with open("/home/xusheng/PythonProject/data/tabel/monolingual/uniform_data_name.entity", "w") as bw:
        for key, val in name['entity'].iteritems():
            bw.write("%s\t%s\n" % (key, val))
    with open("/home/xusheng/PythonProject/data/tabel/monolingual/uniform_data_name.truth", "w") as bw:
        for key, val in name['truth'].iteritems():
            bw.write("%s\t%s\t%s\t%s\n" % (key, val[0], val[1], val[2]))
    with open("/home/xusheng/PythonProject/data/tabel/monolingual/uniform_data_name.surface", "w") as bw:
        for key, val in name['surface'].iteritems():
            bw.write("%s\t%s\n" % (key, val))
    LogInfo.logs("Name saved.")


